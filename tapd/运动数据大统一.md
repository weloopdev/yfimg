[TOC]

# 运动数据大统一

## 固件

固件端会产生原始数据和运动数据

- 原始数据里面包含标签数据和分钟数据


- 运动数据包含轨迹、心率、步频、踏频等等..

### WeLoop

运动数据依赖于原始数据

运动标签从原始数据解析到，然后在根据时间戳去运动数据里面拿到对应的数据

### Coros

coros没有标签的概念

运动数据完全独立，不依赖于原始数据

## 服务器

### 上传

#### 涉及到的数据

*<u>如果某次运动数据单个数据超过500k，只上传一次运动的数据</u>*

- locusData：轨迹数据[时间、经度、纬度、高度、水平精度、速度] 
- heartData：心率数据
- sportData[新加入]：运动数据 
- imageData[新加入]：缩列图（目前只有Coros）

#### 上传二进制流的格式(locusData/heartData/sportData/imageData)

```
Head=UUID[16Byte]Mode[1Byte]Length[4Byte]
Data=Count[2Byte]Head1…HeadnData1…Datan
```

#### 注意点

- **WeLoop之前老的接口locusData和heartData是分开上传的**，为了新版APP上传的数据(轨迹和心率)，老版APP能够使用，故WeLoop还是延续这种方式上传
- 新增的数据统一合并到sportData再上传，比如轨迹需要新增VDOP、StepSecond，VDOP和StepSecond需要合并到sportData里面在上传
- Coros除了imageData之外的所以数据都拼接到sportData里面是上传

### 下载

#### 数据类型

```objective-c
/**
 服务器下发运动详情的类型
 
 组合规则
 Head=Type[1Byte]Length[4Byte]
 Data=Count[1Byte]Head1...HeadnData1..Datan
 */
typedef NS_ENUM(NSUInteger, RunDetailType) {
    RunDetailTypeStep,          // 步频(分钟级别)
    RunDetailTypeLocus,         // 轨迹
    RunDetailTypeHeart,         // 心率
    RunDetailTypeLapSpeed,      // 圈速
    RunDetailTypeSport,         // 新加的运动数据
};
```

#### 下载详情数据的格式

```
 Head=Type[1Byte]Length[4Byte]
 Data=Count[1Byte]Head1...HeadnData1..Datan
```

### 新增的sportData介绍

#### sportType类型

```objective-c
/**
 SportData里面的Type,新增的Type只能让后面加
 
 组合规则
 ItemData=ItemType[1Byte]+DataLength[4Byte]DataCrc[2Byte]+Data
 SportData=ItemData0ItemData1...ItemDatan
 */
typedef enum : NSUInteger {
    YFSportDataTypeGPSTime = 100,       // GPS 时间戳(uint32_t) 1970年
    YFSportDataTypeGPSLatitude,         // GPS 纬度(int32_t) * 10000000
    YFSportDataTypeGPSLongitude,        // GPS 经度(int32_t) * 10000000
    YFSportDataTypeGPSAltitude,         // GPS 高度(int32_t) * 10000
    YFSportDataTypeGPSHdop,             // GPS 水平精度(int32_t) * 10000
    YFSportDataTypeGPSVdop,             // GPS 垂直精度(int32_t) * 10000
    YFSportDataTypeGPSSpeed,            // GPS 速度(int32_t) * 10000
    YFSportDataTypeHeart,               // 心率数据
    YFSportDataTypeStepMinute,          // 步频分钟级别(uint16_t)
    YFSportDataTypeStepSecond,          // 步频秒级别(uint16_t)
    YFSportDataTypeCircleSpeed,         // 圈速
    YFSportDataTypeSwimLap,             // 游泳每趟的数据
    YFSportDataTypeSwimSummary,         // 游泳概要数据
    YFSportDataTypePauseInfo,           // 暂停数据
    YFSportDataTypeStepWideInfo,        // 步幅数据
    YFSportDataTypeCadence,             // 踏频
} YFSportDataType;
```

#### sportData格式

```
ItemData=ItemType[1Byte]+DataLength[4Byte]DataCrc[2Byte]+Data
sportData=ItemData0ItemData1...ItemDatan
```

#### sportData的来源

- 对于Coros来说，sportData只能由App端上传给服务器端

- 对WeLoop来说，sportData有两个来源

  - App端上传，服务器收到App端的数据，直接追加到sportData里面
  - 服务器从解析库里面解析到的数据，直接拼接到sportData

  > 目前sportData的格式可以做到增量上传，服务器每次都是追加就ok
  >
  > App端解析的时候需要注意，当sportDataType可能会重复出现，重复出现的数据都需要解析

## APP端

### 轨迹[locusData]

- WeLoop

```objective-c
typedef struct __attribute__((packed))
{
    uint32_t time;              // 时间 1970的时间戳
    int32_t latitude;           // 纬度 * 10000000
    int32_t longitude;          // 经度 * 10000000
    int32_t altitude;           // 高度 * 10000
    int32_t hdop;               // 水平精度 * 10000
    int32_t speed;              // 速度 * 10000
}locus_info_t;
```

​	[时间、经度、纬度、高度、水平精度、速度]这6个数据，使用locusData上传

​	locusData=locus1[24Byte]…locusn[24Byte]

​	后续新增的VDOP拼接到sportData里面去上传

​	GpsVdopData=vdop1[4Byte]…vdopn[4Byte]

- Coros

  > 格式按照Type的注释的字节数直接组合

  把GPS数据的每个维度作为一类数据拼接到sportData

  [时间、经度、纬度、高度、水平精度、垂直精度、速度]7个数据按需组合

  比如：

  GpsTimeData=time1[4Byte]…timen[4Byte]

  GpslatitudeData=latitude1[4Byte]…latituden[4Byte]

### 心率[heartData]

> magic[1Byte(0xEB)]+timestamp[4Byte]+interval[1Byte]+heart1...heartn[1Byte]

- WeLoop：使用heartData上传


- Coros：拼接到sportData后上传

> 注意小黑3/Now2心率数据是单独返回的，格式为magic+interval+timestamp+heart
>
> 其他有心率设备运动数据混合在一块返回

### 步频分钟级别[stepMinute]

> step[2Byte]

- WeLoop：这个数据不需要app上传，服务器直接从解析库里面解析到


- Coros：没有这个数据

### 步频秒级别[stepSecond]

> step[2Byte]

- WeLoop：拼接到sportData后上传
- Coros：拼接到sportData后上传

### 圈速[circleSpeedData]

> distance[4Byte]duration[4Byte]

- WeLoop：这个数据不需要app上传，服务器直接从解析库里面解析到
- Coros：拼接到sportData后上传

### 游泳趟数据[swimLapData] 本次加入

```objective-c
/**
 游泳的每趟的数据
 */
typedef struct __attribute__((packed)) {
    uint16_t lapspeed;                      // 配速 单位：s/100m
    uint16_t duration;                      // 游泳时长 单位s
    uint16_t strokes;                       // 划水次数
    uint8_t calorie;                        // 卡路里 单位：大卡
    uint8_t type;                           // 游泳姿势
}swim_lap_info;
```

- WeLoop：这个数据不需要app上传，服务器直接从解析库里面解析到data，拼接到sportData下发到app
- Coros：拼接到sportData后上传

### 游泳概要数据[swimSummaryData] 本次加入

```objective-c
/**
 游泳概要信息
 */
typedef struct __attribute__((packed)) {
    uint64_t timestamp;                     // 游泳的开始时间
    uint32_t durtion;                       // 游泳的时长 单位：s
    uint16_t calorie;                       // 卡路里 单位：大卡
    uint16_t speed;                         // 游泳配速 单位：s/100m
    uint16_t pool_length;                   // 泳池长度 单位：m
    uint8_t type;                           // 游泳类型
    int8_t reserved;                        // 保留为了凑齐偶数
}swim_summary_info;
```

- WeLoop：这个数据不需要app上传，服务器直接从解析库里面解析拿到data，拼接到sportData下发到app
- Coros：拼接到sportData后上传

### 暂停数据[pauseData] 下次加入

```objective-c
/**
 运动暂停信息
 */
typedef struct __attribute__((packed)) {
    uint32_t timestamp;              // 暂停的开始时间
    uint16_t duration;               // 暂停的时长 单位s
} sport_pause_info;
```

- WeLoop：这个数据不需要app上传，服务器直接从解析库里面解析拿到data，拼接到sportData下发到app
- Coros：拼接到sportData后上传

### 步幅数据[stepWideData] 待定

这个数据是调用算法计算出来的数据，用于校准用户步幅的

```objective-c
待定
```

- WeLoop：拼接到sportData后上传
- Coros：拼接到sportData后上传

### 踏频[cadenceData]

> 做到的时候在定义

### 缩略图[imageData]

> 图片的二进制流

- WeLoop：没有这个数据
- Coros：使用imageData上传

## 数据组合原则

- 由App端上传的数据，App端统一封装成sportData再上传

  WeLoop轨迹和心率数据除外

- 目前服务器存储的数据有：locusData、heartData、stepMinute、circleSpeedData

  现需加入imageData、sportData，以后sportData里面再加入其他的数据就不需要服务器做任务改动

  服务组合到app的数据再加入一个sportData的type即可


- 由原始数据解析到数据，不需要App再次上传，涉及到圈速、步频分钟级别，服务器直接组合到App就ok

  分钟级别步频、圈速


- 服务器为了兼容新旧接口，老的数据字段都保存，新组合的字段统一存储到sportData，下载详情数据的时候，有什么数据组合什么数据到App
- App解析数据的时候：sportData有的字段优先使用，比如sportData里面有秒级别的步频，服务器又组合了一个分钟级别的步频，app以sportData里面秒级别步频为准